<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PaySentry: The Missing Control Plane for Agent Payments - Michael Yang</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=Playfair+Display:ital,wght@0,400;0,700;0,800;1,400&family=Noto+Serif+SC:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/css/base.css">
    <link rel="stylesheet" href="/css/article.css">
    <link rel="alternate" type="application/rss+xml" title="Michael Yang's Blog" href="/feed.xml">
<!--
BLOG_META
title: PaySentry: The Missing Control Plane for Agent Payments
title_zh: PaySentry：Agent 支付的缺失控制面
date: 2026-02-06
description: PaySentry is the missing middleware between AI agent frameworks and payment protocols &mdash; observe spending, enforce policies, resolve disputes, and test safely across x402, ACP, AP2, and Visa TAP
tags: ai, agent-payment, protocol, open-source, control-plane
bilingual: true
END_META
-->
</head>
<body>
    <!-- Ambient background -->
    <div class="orb orb-1"></div>
    <div class="orb orb-2"></div>
    <div class="grid-overlay"></div>
    <div class="v-line"></div>
    <div class="noise"></div>
    <div class="vignette"></div>

    <div class="page">
        <!-- Top bar -->
        <header class="topbar">
            <a href="/" class="logo">mkyang.ai</a>
            <div class="topbar-right">
                <div class="lang-switch">
                    <span class="lang-label active" data-lang="en">EN</span>
                    <label class="lang-toggle">
                        <input type="checkbox" id="langToggle">
                        <span class="track"></span>
                        <span class="knob"></span>
                    </label>
                    <span class="lang-label" data-lang="zh">中文</span>
                </div>
                <a href="/blog/" class="back-link">&larr; Blog</a>
            </div>
        </header>

        <!-- Article -->
        <article class="article">

            <!-- ==================== ENGLISH ==================== -->
            <div class="lang-content active" id="content-en">
                <div class="article-meta">Michael Yang &middot; February 6, 2026</div>
                <h1 class="article-title">PaySentry: The Missing Control Plane for Agent Payments</h1>
                <p class="article-subtitle">Seven protocols. $80M+ in funding. Zero middleware. Here&rsquo;s the layer nobody built.</p>
                <div class="article-rule"></div>

                <div class="prose">
                    <p>In my <a href="/blog/agent-payment-landscape">previous analysis</a>, I mapped the agent payment landscape and found a fragmented mess: seven competing protocols, no interoperability, no observability, and prompt injection lurking underneath it all.</p>

                    <p>The initial instinct was to build another protocol wrapper with a firewall bolted on. After deeper research &mdash; studying what developers actually struggle with on GitHub issues, HN threads, and Reddit &mdash; I realized the real gap is bigger than security. It&rsquo;s <strong>governance</strong>.</p>

                    <p>Nobody can answer basic questions: <em>What did my agents spend last week? Which agent is burning through budget? What happens when a payment fails? How do I test payment flows without real money?</em></p>

                    <p>The answer isn&rsquo;t another protocol. It&rsquo;s <strong>PaySentry</strong> &mdash; a control plane that sits between agent frameworks (LangChain, CrewAI, AutoGen) and payment rails (x402, ACP, AP2, Visa TAP), giving developers the visibility and control they&rsquo;re missing.</p>

                    <h2>The Real Problem</h2>

                    <p>There are now <strong>seven competing payment standards</strong> for AI agents: x402 (Coinbase), AP2 (Google), ACP (Stripe/OpenAI), Virtuals ACP, ERC-8004, Visa Trusted Agent Protocol, and Mastercard Agent Pay. The funded startups building on them &mdash; Skyfire ($9.5M), Kite ($33M), Natural ($9.8M), Payman ($13.8M), Nevermined ($7M) &mdash; are all racing to own the payment rail itself.</p>

                    <p>But talk to developers actually building agents that spend money, and you hear a different set of complaints:</p>

                    <ul>
                        <li><strong>&ldquo;I have no idea what my agents are spending.&rdquo;</strong> &mdash; There&rsquo;s no dashboard, no analytics, no alerts. You find out about runaway spending when the wallet is empty.</li>
                        <li><strong>&ldquo;I can&rsquo;t set a policy.&rdquo;</strong> &mdash; No equivalent of OPA or AWS IAM for agent payments. Every team builds ad-hoc if/else guards in application code.</li>
                        <li><strong>&ldquo;When something goes wrong, I&rsquo;m on my own.&rdquo;</strong> &mdash; No dispute resolution, no audit trail, no automated recovery. Agent-to-agent payment failures are silent.</li>
                        <li><strong>&ldquo;Testing is terrifying.&rdquo;</strong> &mdash; No sandbox environment. Developers test with real money on mainnet because there&rsquo;s no mock infrastructure for agent payment protocols.</li>
                    </ul>

                    <p>These aren&rsquo;t niche complaints. They&rsquo;re the same problems every infrastructure category hits at scale: you need a control plane.</p>

                    <div class="section-divider"></div>

                    <h2>The Insight</h2>

                    <p>Every mature infrastructure has a control plane separate from its data plane. Kubernetes has it. Service meshes have it. Databases have it. Agent payments don&rsquo;t.</p>

                    <blockquote><strong>The protocols are the data plane. What&rsquo;s missing is the control plane &mdash; observe, control, protect, test.</strong></blockquote>

                    <p>This isn&rsquo;t about replacing x402 or competing with ACP. It&rsquo;s about building the middleware layer that makes <em>any</em> payment protocol manageable in production. The same way Datadog doesn&rsquo;t replace your servers but makes them observable, PaySentry doesn&rsquo;t replace payment protocols but makes them governable.</p>

                    <div class="section-divider"></div>

                    <h2>PaySentry: Four Pillars</h2>

                    <h3>1. Observe &mdash; Know What Your Agents Spend</h3>

                    <p>Real-time spending analytics across all protocols. Per-agent breakdowns, time-series tracking, budget alerts, anomaly detection. Think Datadog for agent payments.</p>

<pre><code>import { SpendTracker } from '@paysentry/observe';

const tracker = new SpendTracker();
tracker.record(transaction);

// Per-agent spending breakdown
const breakdown = tracker.getAgentBreakdown('agent-007');
// { totalSpent: 847.30, txCount: 23, byProtocol: { x402: 612, acp: 235.30 } }

// Budget alerts
tracker.onAlert('budget-80pct', (agent, spent, limit) => {
  slack.notify(`${agent} at ${(spent/limit*100).toFixed(0)}% budget`);
});</code></pre>

                    <h3>2. Control &mdash; Enforce Policies Before Funds Move</h3>

                    <p>A policy engine for agent payments. Spending limits, recipient whitelists, category restrictions, time-of-day rules, per-agent budgets. Deterministic rules that no LLM can override. OPA for payments.</p>

<pre><code>import { PolicyEngine, RuleBuilder } from '@paysentry/control';

const policy = new RuleBuilder()
  .maxPerTransaction(100)
  .dailyBudget('agent-007', 1000)
  .allowRecipients(['*.verified', 'api.openai.com'])
  .blockCategories(['gambling', 'adult'])
  .requireApproval(amount => amount > 500)
  .build();

const engine = new PolicyEngine([policy]);
const verdict = engine.evaluate(transaction);
// { allowed: false, reason: 'Exceeds daily budget (spent: $940, limit: $1000)' }</code></pre>

                    <h3>3. Protect &mdash; Audit, Dispute, Recover</h3>

                    <p>Immutable audit trail for every transaction. Full dispute lifecycle management. Automated recovery with retry logic. When an agent-to-agent payment goes wrong, PaySentry provides the tooling to investigate, escalate, and resolve.</p>

<pre><code>import { AuditTrail, DisputeManager } from '@paysentry/protect';

// Immutable audit log
const trail = new AuditTrail();
trail.log(transaction, { agentId, userId, policyResult, metadata });

// Dispute lifecycle
const dispute = disputes.open({
  transactionId: 'tx_abc123',
  reason: 'Service not delivered within deadline',
  evidence: [{ type: 'timeout', deadline: '24h', elapsed: '72h' }]
});
// States: open → investigating → resolved / escalated</code></pre>

                    <h3>4. Test &mdash; Ship Without Fear</h3>

                    <p>Mock implementations of x402, ACP, and AP2 for local development. Pre-built test scenarios: happy paths, timeouts, insufficient funds, dispute flows, prompt injection attempts. Developers test payment integrations without spending real money.</p>

<pre><code>import { MockX402, MockACP, scenarios } from '@paysentry/sandbox';

const mockX402 = new MockX402({ failRate: 0.1 }); // 10% random failures
const mockACP = new MockACP({ latency: 200 });     // 200ms simulated delay

// Run pre-built scenarios
const results = await scenarios.run('budget-exceeded');
// Tests: agent hits budget limit → policy blocks → alert fires → audit logged</code></pre>

                    <div class="section-divider"></div>

                    <h2>Why Not Just Use X?</h2>

                    <table>
                        <tr><th>Player</th><th>What They Do</th><th>What&rsquo;s Missing</th></tr>
                        <tr><td><strong>Kite</strong> ($33M)</td><td>New L1 blockchain for agent payments</td><td>Cold start. No observability, no policy engine, no sandbox.</td></tr>
                        <tr><td><strong>Skyfire</strong> ($9.5M)</td><td>Custodial agent wallets + USDC on Base</td><td>Custodial = single point of failure. No multi-protocol. No dispute resolution.</td></tr>
                        <tr><td><strong>Payman</strong> ($13.8M)</td><td>Gateway + policy engine + marketplace</td><td>Trying to be everything. No testing infrastructure. No audit trail.</td></tr>
                        <tr><td><strong>Nevermined</strong> ($7M)</td><td>Metering and billing for AI services</td><td>Billing only. No security, no disputes, no sandbox.</td></tr>
                        <tr><td><strong>SpendSafe</strong></td><td>Non-custodial spending guardrails</td><td>Crypto-only. Single protocol. No observability.</td></tr>
                    </table>

                    <p><strong>PaySentry&rsquo;s positioning:</strong> We don&rsquo;t build payment rails. We don&rsquo;t hold funds. We don&rsquo;t compete with protocols. We&rsquo;re the control plane that makes <em>every</em> protocol production-ready &mdash; observable, governable, auditable, testable.</p>

                    <p>The closest analogy: PaySentry is to agent payments what Datadog + OPA + PagerDuty is to cloud infrastructure. Nobody questions whether you need observability and policy enforcement for your servers. The same will be true for agents that spend money.</p>

                    <div class="section-divider"></div>

                    <h2>Prompt Injection: A Control Plane Problem</h2>

                    <p>The academic consensus (ICSE 2026, ICLR 2025, OWASP) is clear: prompt injection is <strong>unsolvable at the model level</strong>. Anthropic has reduced attack success to 1.4% with Claude Opus, but 1.4% of $600M+ in annual x402 volume is still $8.4M in potential fraud.</p>

                    <p>Most projects treat this as a security problem and build classifiers. PaySentry treats it as a <strong>governance problem</strong>:</p>

                    <ul>
                        <li><strong>Observe</strong> &mdash; Detect anomalous spending patterns that suggest compromise. An agent suddenly spending 10x its normal rate triggers alerts.</li>
                        <li><strong>Control</strong> &mdash; Deterministic policies that no injected prompt can override. A $100 limit is a $100 limit, enforced in code, not in prompts.</li>
                        <li><strong>Protect</strong> &mdash; When an attack succeeds (and some will), the audit trail provides forensics and the dispute system enables recovery.</li>
                        <li><strong>Test</strong> &mdash; Pre-built injection scenarios let developers verify their defenses before production.</li>
                    </ul>

                    <p>This is defense in depth, not defense by prayer. Even if an agent is fully compromised, the control plane limits the blast radius.</p>

                    <div class="section-divider"></div>

                    <h2>Architecture</h2>

<pre><code>┌─────────────────────────────────────────────┐
│         Agent Framework Layer                │
│    (LangChain / CrewAI / AutoGen / custom)   │
└──────────────────┬──────────────────────────┘
                   │  payment intent
                   ▼
┌─────────────────────────────────────────────┐
│              PaySentry Control Plane          │
│                                               │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐     │
│  │ Observe  │ │ Control  │ │ Protect  │     │
│  │ tracking │ │ policies │ │ disputes │     │
│  │ alerts   │ │ rules    │ │ audit    │     │
│  │ analytics│ │ middleware│ │ recovery │     │
│  └──────────┘ └──────────┘ └──────────┘     │
│                                               │
│  ┌──────────────────────────────────────┐    │
│  │    Sandbox (dev/test only)           │    │
│  │    mock-x402 / mock-acp / mock-ap2   │    │
│  └──────────────────────────────────────┘    │
└──────────────────┬──────────────────────────┘
                   │  validated transaction
                   ▼
┌─────────────────────────────────────────────┐
│           Payment Protocol Layer             │
│  x402 (Coinbase) │ ACP (Stripe) │ AP2 (Google)│
│  Visa TAP │ Mastercard Agent Pay │ ERC-8004  │
└─────────────────────────────────────────────┘</code></pre>

                    <p>PaySentry is <strong>non-custodial</strong> and <strong>protocol-agnostic</strong>. It intercepts payment intents, applies policies, logs everything, and passes validated transactions to the underlying protocol. It never touches private keys or holds funds.</p>

                    <div class="section-divider"></div>

                    <h2>Revenue Model</h2>

                    <table>
                        <tr><th>Tier</th><th>Price</th><th>What You Get</th></tr>
                        <tr><td><strong>Open Source</strong></td><td>Free</td><td>All 5 packages. Full control plane. Community support.</td></tr>
                        <tr><td><strong>Cloud</strong></td><td>$99/mo</td><td>Hosted dashboard, managed alerts, cross-agent analytics. 10K transactions/mo.</td></tr>
                        <tr><td><strong>Enterprise</strong></td><td>Custom</td><td>Custom policies, compliance reporting, SLA, dedicated support.</td></tr>
                    </table>

                    <p>The open-source core builds adoption. The cloud dashboard is the paid product &mdash; developers want hosted observability, not another self-hosted tool. The data moat grows with every transaction logged.</p>

                    <div class="section-divider"></div>

                    <h2>The Bet</h2>

                    <p>The agent payment market is projected at $136B in 2026, growing to $1.7T by 2030. Seven protocols are competing. $80M+ in VC money has been deployed. Everyone is building rails. Nobody is building the control plane.</p>

                    <p>Kubernetes didn&rsquo;t win by being a better container runtime. It won by being the control plane for <em>all</em> container runtimes. PaySentry is the same play: don&rsquo;t replace the protocols, <strong>make them manageable</strong>.</p>

                    <p>The question isn&rsquo;t whether agents will spend money autonomously &mdash; they already are. The question is whether anyone will know what they&rsquo;re spending, be able to set limits, investigate failures, and test safely. That&rsquo;s what we&rsquo;re building.</p>

                    <p><strong><a href="/paysentry">Explore PaySentry &rarr;</a></strong></p>
                </div>
            </div>

            <!-- ==================== CHINESE ==================== -->
            <div class="lang-content" id="content-zh">
                <div class="article-meta">Michael Yang &middot; 2026 年 2 月 6 日</div>
                <h1 class="article-title">PaySentry：Agent 支付的缺失控制面</h1>
                <p class="article-subtitle">七个协议、8000 万+ 美元融资、零中间件。这是没有人造的那一层。</p>
                <div class="article-rule"></div>

                <div class="prose">
                    <p>在我<a href="/blog/agent-payment-landscape">上一篇分析</a>中，我画了一张 Agent 支付赛道的全景图，发现了一片狼藉：七个互相竞争的协议、不互通、没有可观测性，而且 prompt injection 埋在所有东西下面。</p>

                    <p>最初的直觉是造另一个协议封装器加个防火墙。但更深入的研究 &mdash; 研究开发者在 GitHub issues、HN 和 Reddit 上真正在吐槽什么 &mdash; 让我意识到真正的缺口比安全更大。是<strong>治理</strong>。</p>

                    <p>没人能回答这些基本问题：<em>我的 Agent 上周花了多少？哪个 Agent 在烧预算？支付失败了怎么办？怎么在不花真钱的情况下测试支付流程？</em></p>

                    <p>答案不是另一个协议。是 <strong>PaySentry</strong> &mdash; 一个位于 Agent 框架（LangChain、CrewAI、AutoGen）和支付轨道（x402、ACP、AP2、Visa TAP）之间的控制面，给开发者缺失的可见性和控制力。</p>

                    <h2>真正的问题</h2>

                    <p>现在有 <strong>七个互相竞争的 Agent 支付标准</strong>：x402（Coinbase）、AP2（Google）、ACP（Stripe/OpenAI）、Virtuals ACP、ERC-8004、Visa Trusted Agent Protocol、Mastercard Agent Pay。在上面建设的融资创业公司 &mdash; Skyfire（$950 万）、Kite（$3300 万）、Natural（$980 万）、Payman（$1380 万）、Nevermined（$700 万）&mdash; 都在争夺支付轨道本身。</p>

                    <p>但跟真正在造会花钱的 Agent 的开发者聊，你听到的是另一组抱怨：</p>

                    <ul>
                        <li><strong>&ldquo;我完全不知道我的 Agent 花了多少。&rdquo;</strong> &mdash; 没有仪表盘，没有分析，没有告警。你发现失控消费的时候，钱包已经空了。</li>
                        <li><strong>&ldquo;我没法设置策略。&rdquo;</strong> &mdash; Agent 支付没有等同于 OPA 或 AWS IAM 的东西。每个团队在应用代码里堆 if/else 土法守卫。</li>
                        <li><strong>&ldquo;出问题了，全靠我自己。&rdquo;</strong> &mdash; 没有争议解决，没有审计日志，没有自动恢复。Agent 对 Agent 的支付失败是静默的。</li>
                        <li><strong>&ldquo;测试太恐怖了。&rdquo;</strong> &mdash; 没有沙盒环境。开发者在主网用真钱测试，因为 Agent 支付协议没有 mock 基础设施。</li>
                    </ul>

                    <p>这不是小众问题。这是每个基础设施品类在规模化时都会遇到的问题：你需要一个控制面。</p>

                    <div class="section-divider"></div>

                    <h2>核心洞察</h2>

                    <p>每个成熟的基础设施都有一个独立于数据面的控制面。Kubernetes 有。Service mesh 有。数据库有。Agent 支付没有。</p>

                    <blockquote><strong>协议是数据面。缺失的是控制面 &mdash; 观测、控制、保护、测试。</strong></blockquote>

                    <p>这不是要替换 x402 或跟 ACP 竞争。是建设让<em>任何</em>支付协议在生产环境可管理的中间件层。就像 Datadog 不替换你的服务器但让它们可观测一样，PaySentry 不替换支付协议但让它们可治理。</p>

                    <div class="section-divider"></div>

                    <h2>PaySentry：四大支柱</h2>

                    <h3>1. Observe &mdash; 知道你的 Agent 在花什么</h3>

                    <p>跨所有协议的实时消费分析。逐 Agent 分解、时间序列追踪、预算告警、异常检测。Agent 支付的 Datadog。</p>

<pre><code>import { SpendTracker } from '@paysentry/observe';

const tracker = new SpendTracker();
tracker.record(transaction);

// 逐 Agent 消费分解
const breakdown = tracker.getAgentBreakdown('agent-007');
// { totalSpent: 847.30, txCount: 23, byProtocol: { x402: 612, acp: 235.30 } }

// 预算告警
tracker.onAlert('budget-80pct', (agent, spent, limit) => {
  slack.notify(`${agent} 已用 ${(spent/limit*100).toFixed(0)}% 预算`);
});</code></pre>

                    <h3>2. Control &mdash; 在资金移动之前执行策略</h3>

                    <p>Agent 支付的策略引擎。消费限额、收款人白名单、类别限制、时间规则、逐 Agent 预算。确定性规则，没有 LLM 能覆盖。支付版 OPA。</p>

<pre><code>import { PolicyEngine, RuleBuilder } from '@paysentry/control';

const policy = new RuleBuilder()
  .maxPerTransaction(100)
  .dailyBudget('agent-007', 1000)
  .allowRecipients(['*.verified', 'api.openai.com'])
  .blockCategories(['gambling', 'adult'])
  .requireApproval(amount => amount > 500)
  .build();

const engine = new PolicyEngine([policy]);
const verdict = engine.evaluate(transaction);
// { allowed: false, reason: '超出日预算 (已花: $940, 限额: $1000)' }</code></pre>

                    <h3>3. Protect &mdash; 审计、争议、恢复</h3>

                    <p>每笔交易的不可变审计日志。完整的争议生命周期管理。带重试逻辑的自动恢复。当 Agent 对 Agent 的支付出问题时，PaySentry 提供调查、升级和解决的工具链。</p>

<pre><code>import { AuditTrail, DisputeManager } from '@paysentry/protect';

// 不可变审计日志
const trail = new AuditTrail();
trail.log(transaction, { agentId, userId, policyResult, metadata });

// 争议生命周期
const dispute = disputes.open({
  transactionId: 'tx_abc123',
  reason: '服务未在截止时间内交付',
  evidence: [{ type: 'timeout', deadline: '24h', elapsed: '72h' }]
});
// 状态: open → investigating → resolved / escalated</code></pre>

                    <h3>4. Test &mdash; 无惧上线</h3>

                    <p>x402、ACP 和 AP2 的本地开发 mock 实现。预置测试场景：正常路径、超时、余额不足、争议流程、prompt injection 尝试。开发者不花真钱就能测试支付集成。</p>

<pre><code>import { MockX402, MockACP, scenarios } from '@paysentry/sandbox';

const mockX402 = new MockX402({ failRate: 0.1 }); // 10% 随机失败
const mockACP = new MockACP({ latency: 200 });     // 200ms 模拟延迟

// 运行预置场景
const results = await scenarios.run('budget-exceeded');
// 测试: agent 触达预算上限 → 策略拦截 → 告警触发 → 审计记录</code></pre>

                    <div class="section-divider"></div>

                    <h2>为什么不直接用 X？</h2>

                    <table>
                        <tr><th>玩家</th><th>做什么</th><th>缺什么</th></tr>
                        <tr><td><strong>Kite</strong>（$3300万）</td><td>Agent 支付新公链</td><td>冷启动。没有可观测性、策略引擎、沙盒。</td></tr>
                        <tr><td><strong>Skyfire</strong>（$950万）</td><td>托管 Agent 钱包 + Base USDC</td><td>托管 = 单点故障。不支持多协议。没有争议解决。</td></tr>
                        <tr><td><strong>Payman</strong>（$1380万）</td><td>网关 + 策略引擎 + 市场</td><td>什么都想做。没有测试基础设施。没有审计日志。</td></tr>
                        <tr><td><strong>Nevermined</strong>（$700万）</td><td>AI 服务计量和计费</td><td>只做计费。没有安全、争议、沙盒。</td></tr>
                        <tr><td><strong>SpendSafe</strong></td><td>非托管消费防护栏</td><td>只支持 crypto。单协议。没有可观测性。</td></tr>
                    </table>

                    <p><strong>PaySentry 的定位：</strong>我们不造支付轨道。不托管资金。不跟协议竞争。我们是让<em>每个</em>协议都能投产的控制面 &mdash; 可观测、可治理、可审计、可测试。</p>

                    <p>最贴切的类比：PaySentry 之于 Agent 支付，就像 Datadog + OPA + PagerDuty 之于云基础设施。没有人质疑你的服务器是否需要可观测性和策略执行。Agent 花钱也一样。</p>

                    <div class="section-divider"></div>

                    <h2>Prompt Injection：一个控制面问题</h2>

                    <p>学术界的共识（ICSE 2026、ICLR 2025、OWASP）很明确：prompt injection <strong>在模型层面无法解决</strong>。Anthropic 用 Claude Opus 把攻击成功率降到了 1.4%，但 x402 年化交易额 $6 亿+ 的 1.4% 仍然是 $840 万的潜在欺诈。</p>

                    <p>大多数项目把这当安全问题来造分类器。PaySentry 把它当<strong>治理问题</strong>：</p>

                    <ul>
                        <li><strong>Observe</strong> &mdash; 检测暗示入侵的异常消费模式。Agent 突然以 10 倍正常速率消费会触发告警。</li>
                        <li><strong>Control</strong> &mdash; 确定性策略，没有注入的 prompt 能覆盖。$100 限额就是 $100 限额，在代码中执行，不在 prompt 中。</li>
                        <li><strong>Protect</strong> &mdash; 当攻击得逞（总会有的），审计日志提供取证，争议系统启动恢复。</li>
                        <li><strong>Test</strong> &mdash; 预置注入场景让开发者在上线前验证防御。</li>
                    </ul>

                    <p>这是纵深防御，不是祈祷防御。即使 Agent 完全被入侵，控制面限制了爆炸半径。</p>

                    <div class="section-divider"></div>

                    <h2>架构</h2>

<pre><code>┌─────────────────────────────────────────────┐
│           Agent 框架层                       │
│    (LangChain / CrewAI / AutoGen / 自定义)    │
└──────────────────┬──────────────────────────┘
                   │  支付意图
                   ▼
┌─────────────────────────────────────────────┐
│            PaySentry 控制面                   │
│                                               │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐     │
│  │ Observe  │ │ Control  │ │ Protect  │     │
│  │ 追踪     │ │ 策略     │ │ 争议     │     │
│  │ 告警     │ │ 规则     │ │ 审计     │     │
│  │ 分析     │ │ 中间件   │ │ 恢复     │     │
│  └──────────┘ └──────────┘ └──────────┘     │
│                                               │
│  ┌──────────────────────────────────────┐    │
│  │    Sandbox（仅开发/测试）             │    │
│  │    mock-x402 / mock-acp / mock-ap2   │    │
│  └──────────────────────────────────────┘    │
└──────────────────┬──────────────────────────┘
                   │  验证后的交易
                   ▼
┌─────────────────────────────────────────────┐
│           支付协议层                          │
│  x402 (Coinbase) │ ACP (Stripe) │ AP2 (Google)│
│  Visa TAP │ Mastercard Agent Pay │ ERC-8004  │
└─────────────────────────────────────────────┘</code></pre>

                    <p>PaySentry 是<strong>非托管</strong>且<strong>协议无关</strong>的。它拦截支付意图，应用策略，记录一切，然后把验证后的交易传给底层协议。它永远不碰私钥或持有资金。</p>

                    <div class="section-divider"></div>

                    <h2>收入模型</h2>

                    <table>
                        <tr><th>层级</th><th>价格</th><th>包含什么</th></tr>
                        <tr><td><strong>开源版</strong></td><td>免费</td><td>全部 5 个包。完整控制面。社区支持。</td></tr>
                        <tr><td><strong>云版</strong></td><td>$99/月</td><td>托管仪表盘、托管告警、跨 Agent 分析。10K 交易/月。</td></tr>
                        <tr><td><strong>企业版</strong></td><td>定制</td><td>自定义策略、合规报告、SLA、专属支持。</td></tr>
                    </table>

                    <p>开源核心建立采用。云仪表盘是付费产品 &mdash; 开发者要的是托管的可观测性，不是又一个自己运维的工具。数据护城河随每笔记录的交易增长。</p>

                    <div class="section-divider"></div>

                    <h2>赌注</h2>

                    <p>Agent 支付市场预计 2026 年达 $1360 亿，2030 年达 $1.7 万亿。七个协议在竞争。$8000 万+ 的 VC 资金已经投下。所有人都在造轨道。没人在造控制面。</p>

                    <p>Kubernetes 赢了不是因为它是更好的容器运行时。它赢了因为它是<em>所有</em>容器运行时的控制面。PaySentry 是同样的打法：不替换协议，<strong>让它们可管理</strong>。</p>

                    <p>问题不是 Agent 会不会自主花钱 &mdash; 它们已经在花了。问题是有没有人知道它们在花什么、能不能设限额、能不能查失败、能不能安全地测试。这就是我们在做的事。</p>

                    <p><strong><a href="/paysentry">探索 PaySentry &rarr;</a></strong></p>
                </div>
            </div>

            <!-- Next Post -->
            <div class="next-post">
                <a href="/blog/agent-payment-security">Next <span class="next-arrow">&rarr;</span></a>
            </div>

            <!-- Footer -->
            <footer class="article-footer">
                <nav class="links">
                    <a href="/">Home</a>
                    <a href="https://github.com/MichaelYangzk" target="_blank" rel="noopener">GitHub</a>
                    <a href="https://x.com/bayc2043" target="_blank" rel="noopener">X / Twitter</a>
                    <a href="mailto:yangzk01@gmail.com">Email</a>
                </nav>
                <span class="copyright">&copy; 2026 Michael Yang</span>
            </footer>
        </article>
    </div>

    <script>
        const toggle = document.getElementById('langToggle');
        const enContent = document.getElementById('content-en');
        const zhContent = document.getElementById('content-zh');
        const enLabel = document.querySelector('.lang-label[data-lang="en"]');
        const zhLabel = document.querySelector('.lang-label[data-lang="zh"]');

        function setLang(lang) {
            if (lang === 'zh') {
                toggle.checked = true;
                enContent.classList.remove('active');
                zhContent.classList.add('active');
                enLabel.classList.remove('active');
                zhLabel.classList.add('active');
                document.documentElement.lang = 'zh-CN';
                document.title = 'PaySentry：Agent 支付的缺失控制面 - Michael Yang';
            } else {
                toggle.checked = false;
                zhContent.classList.remove('active');
                enContent.classList.add('active');
                zhLabel.classList.remove('active');
                enLabel.classList.add('active');
                document.documentElement.lang = 'en';
                document.title = 'PaySentry: The Missing Control Plane for Agent Payments - Michael Yang';
            }
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        toggle.addEventListener('change', () => {
            setLang(toggle.checked ? 'zh' : 'en');
        });

        enLabel.addEventListener('click', () => setLang('en'));
        zhLabel.addEventListener('click', () => setLang('zh'));
    </script>
</body>
</html>
